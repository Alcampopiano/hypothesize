{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hypothesize: robust statistics in Python Hypothesize is a robust statistics library for Python based on Rand R. Wilcox's R package WRS . With Hypothesize you can compare groups and measure associations using methods that outperform traditional statistcal approaches in terms of power and accuracy. For more information on robust methods please see Wilcox's book Introduction to Robust Estimation and Hypothesis Testing . Getting Started Overview Installation Dependencies Basic Tutorial Function Guide Comparing groups with a single factor independent groups l2drmci linconb pb2gen tmcppb yuenbt dependent groups bootdpci rmmcppb l2drmci lindepbt ydbt Comparing groups with two factors dependent groups wwmcppb wwmcpbt mixed designs bwamcp bwbmcp bwcmp bwimcp bwmcppb spmcpa spmcpb spmcpi Measuring associations corb pball pbcor winall wincor Bug reports and Questions Hypothesize is BSD-licenced and the source code is available on GitHub . For issues and questions, please use GitHub Issues","title":"Home"},{"location":"#hypothesize-robust-statistics-in-python","text":"Hypothesize is a robust statistics library for Python based on Rand R. Wilcox's R package WRS . With Hypothesize you can compare groups and measure associations using methods that outperform traditional statistcal approaches in terms of power and accuracy. For more information on robust methods please see Wilcox's book Introduction to Robust Estimation and Hypothesis Testing .","title":"Hypothesize: robust statistics in Python"},{"location":"#getting-started","text":"Overview Installation Dependencies Basic Tutorial","title":"Getting Started"},{"location":"#function-guide","text":"","title":"Function Guide"},{"location":"#comparing-groups-with-a-single-factor","text":"","title":"Comparing groups with a single factor"},{"location":"#independent-groups","text":"l2drmci linconb pb2gen tmcppb yuenbt","title":"independent groups"},{"location":"#dependent-groups","text":"bootdpci rmmcppb l2drmci lindepbt ydbt","title":"dependent groups"},{"location":"#comparing-groups-with-two-factors","text":"","title":"Comparing groups with two factors"},{"location":"#dependent-groups_1","text":"wwmcppb wwmcpbt","title":"dependent groups"},{"location":"#mixed-designs","text":"bwamcp bwbmcp bwcmp bwimcp bwmcppb spmcpa spmcpb spmcpi","title":"mixed designs"},{"location":"#measuring-associations","text":"corb pball pbcor winall wincor","title":"Measuring associations"},{"location":"#bug-reports-and-questions","text":"Hypothesize is BSD-licenced and the source code is available on GitHub . For issues and questions, please use GitHub Issues","title":"Bug reports and Questions"},{"location":"basic_tutorial/","text":"Basic Tutorial The following tutorial demonstrates how to perform a robust hypothesis test using 20% trimmed means and the bootstrap-t test. The data correspond to a 2 (between-subjects) x 3 (within-subjects) factorial design. Getting your data into Hypothesize In Hypothesize, input data are always specified as a Pandas DataFrame or Series. In this example, we have a 2x3 factorial design so the data would take the form of a six-column DataFrame (i.e., J levels x K levels). Using Pandas you can read your data into Python and use one of the appropriate functions from Hypothesize. In this case we will use the function bwmcp but there are many others to choose from. \"What about my column names?\" Don't worry, Hypothesize doesn't make use of your column names. Feel free to name them however you like! import pandas as pd df=pd.read_csv('my_data.csv') df.head() cell_1_1 cell_1_2 cell_1_3 cell_2_1 cell_2_2 cell_2_3 0 0.04 0.90 0.79 0.51 0.33 0.23 1 0.76 0.29 0.84 0.03 0.5 0.73 2 0.71 0.59 0.11 0.89 0.76 0.04 3 0.17 0.26 0.88 0.28 0.1 0.21 4 0.95 0.22 0.83 0.59 0.65 0.20 from hypothesize.compare_groups_with_two_factors import bwmcp results=bwmcp(J=2, K=3, x=df) Examining your results The results are returned as a Python Dictionary containing simple Python objects or DataFrames (when the results are best given as a matrix). For example, here are the previously computed results for the interaction returned as a DataFrame. results['factor_AB'] con_num psihat se test crit_value p_value 0 0 -0.100698 0.126135 -0.798336 2.3771 0.410684 1 1 -0.037972 0.151841 -0.250078 2.3771 0.804674 2 2 0.0627261 0.135392 0.463291 2.3771 0.659432 Try this example yourself in Colab!","title":"Tutorial"},{"location":"basic_tutorial/#basic-tutorial","text":"The following tutorial demonstrates how to perform a robust hypothesis test using 20% trimmed means and the bootstrap-t test. The data correspond to a 2 (between-subjects) x 3 (within-subjects) factorial design.","title":"Basic Tutorial"},{"location":"basic_tutorial/#getting-your-data-into-hypothesize","text":"In Hypothesize, input data are always specified as a Pandas DataFrame or Series. In this example, we have a 2x3 factorial design so the data would take the form of a six-column DataFrame (i.e., J levels x K levels). Using Pandas you can read your data into Python and use one of the appropriate functions from Hypothesize. In this case we will use the function bwmcp but there are many others to choose from. \"What about my column names?\" Don't worry, Hypothesize doesn't make use of your column names. Feel free to name them however you like! import pandas as pd df=pd.read_csv('my_data.csv') df.head() cell_1_1 cell_1_2 cell_1_3 cell_2_1 cell_2_2 cell_2_3 0 0.04 0.90 0.79 0.51 0.33 0.23 1 0.76 0.29 0.84 0.03 0.5 0.73 2 0.71 0.59 0.11 0.89 0.76 0.04 3 0.17 0.26 0.88 0.28 0.1 0.21 4 0.95 0.22 0.83 0.59 0.65 0.20 from hypothesize.compare_groups_with_two_factors import bwmcp results=bwmcp(J=2, K=3, x=df)","title":"Getting your data into Hypothesize"},{"location":"basic_tutorial/#examining-your-results","text":"The results are returned as a Python Dictionary containing simple Python objects or DataFrames (when the results are best given as a matrix). For example, here are the previously computed results for the interaction returned as a DataFrame. results['factor_AB'] con_num psihat se test crit_value p_value 0 0 -0.100698 0.126135 -0.798336 2.3771 0.410684 1 1 -0.037972 0.151841 -0.250078 2.3771 0.804674 2 2 0.0627261 0.135392 0.463291 2.3771 0.659432 Try this example yourself in Colab!","title":"Examining your results"},{"location":"function_guide/","text":"Function Reference Hypothesize exposes the following top-level functions for comparing groups and measuring associations. The function names, code, and descriptions are kept generally consistent with Wilcox's WRS package. If you want to learn more about the theory and research behind any given function here, see Wilcox's books, especially Introduction to Robust Estimation and Hypothesis Testing . Comparing groups with a single factor Independent groups l2drmci l2drmci(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! linconb linconb(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! pb2gen pb2gen(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! tmcppb tmcppb(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! yuenbt yuenbt(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! Dependent groups bootdpci bootdpci(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! rmmcppb rmmcppb(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! lindepbt lindepbt(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! ydbt ydbt(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! Comparing groups with two factors Dependent groups wwmcppb wwmcppb(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! wwmcpbt wwmcpbt(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! Mixed designs These designs are also known as \"split-plot\" or \"between-within\" desgins. Hypothesize follws the common convention that assumes that the between-subjects factor is factor A and the within-subjects conditions are Factor B. For example, in a 2x3 mixed design, factor A has two levels. For each of these levels, there are 3 within-subjects conditions. Make sure your DataFrame corresponds to a between-within design, not the other way around For example, in a 2x3 mixed design, the first 3 columns correspond to the first level of Factor A. The last 3 columns correspond to the second level of factor A. bwamcp bwamcp(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! bwbmcp bwbmcp(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! bwcmp bwcmp(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! bwimcp bwimcp(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! bwmcppb bwmcppb(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! spmcpa spmcpa(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! spmcpb spmcpb(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! spmcpi spmcpi(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! Measuring associations These functions deal with correlational statistics (and eventually regression). For some of these functions, the input data are given as a Pandas Series for x and for `y'. corb corb(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! pball pball(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! pbcor pbcor(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! winall winall(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab! wincor wincor(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"Function Reference"},{"location":"function_guide/#function-reference","text":"Hypothesize exposes the following top-level functions for comparing groups and measuring associations. The function names, code, and descriptions are kept generally consistent with Wilcox's WRS package. If you want to learn more about the theory and research behind any given function here, see Wilcox's books, especially Introduction to Robust Estimation and Hypothesis Testing .","title":"Function Reference"},{"location":"function_guide/#comparing-groups-with-a-single-factor","text":"","title":"Comparing groups with a single factor"},{"location":"function_guide/#independent-groups","text":"","title":"Independent groups"},{"location":"function_guide/#l2drmci","text":"l2drmci(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"l2drmci"},{"location":"function_guide/#linconb","text":"linconb(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"linconb"},{"location":"function_guide/#pb2gen","text":"pb2gen(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"pb2gen"},{"location":"function_guide/#tmcppb","text":"tmcppb(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"tmcppb"},{"location":"function_guide/#yuenbt","text":"yuenbt(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"yuenbt"},{"location":"function_guide/#dependent-groups","text":"","title":"Dependent groups"},{"location":"function_guide/#bootdpci","text":"bootdpci(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"bootdpci"},{"location":"function_guide/#rmmcppb","text":"rmmcppb(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"rmmcppb"},{"location":"function_guide/#lindepbt","text":"lindepbt(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"lindepbt"},{"location":"function_guide/#ydbt","text":"ydbt(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"ydbt"},{"location":"function_guide/#comparing-groups-with-two-factors","text":"","title":"Comparing groups with two factors"},{"location":"function_guide/#dependent-groups_1","text":"","title":"Dependent groups"},{"location":"function_guide/#wwmcppb","text":"wwmcppb(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"wwmcppb"},{"location":"function_guide/#wwmcpbt","text":"wwmcpbt(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"wwmcpbt"},{"location":"function_guide/#mixed-designs","text":"These designs are also known as \"split-plot\" or \"between-within\" desgins. Hypothesize follws the common convention that assumes that the between-subjects factor is factor A and the within-subjects conditions are Factor B. For example, in a 2x3 mixed design, factor A has two levels. For each of these levels, there are 3 within-subjects conditions. Make sure your DataFrame corresponds to a between-within design, not the other way around For example, in a 2x3 mixed design, the first 3 columns correspond to the first level of Factor A. The last 3 columns correspond to the second level of factor A.","title":"Mixed designs"},{"location":"function_guide/#bwamcp","text":"bwamcp(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"bwamcp"},{"location":"function_guide/#bwbmcp","text":"bwbmcp(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"bwbmcp"},{"location":"function_guide/#bwcmp","text":"bwcmp(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"bwcmp"},{"location":"function_guide/#bwimcp","text":"bwimcp(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"bwimcp"},{"location":"function_guide/#bwmcppb","text":"bwmcppb(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"bwmcppb"},{"location":"function_guide/#spmcpa","text":"spmcpa(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"spmcpa"},{"location":"function_guide/#spmcpb","text":"spmcpb(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"spmcpb"},{"location":"function_guide/#spmcpi","text":"spmcpi(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"spmcpi"},{"location":"function_guide/#measuring-associations","text":"These functions deal with correlational statistics (and eventually regression). For some of these functions, the input data are given as a Pandas Series for x and for `y'.","title":"Measuring associations"},{"location":"function_guide/#corb","text":"corb(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"corb"},{"location":"function_guide/#pball","text":"pball(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"pball"},{"location":"function_guide/#pbcor","text":"pbcor(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"pbcor"},{"location":"function_guide/#winall","text":"winall(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"winall"},{"location":"function_guide/#wincor","text":"wincor(x, y, est, *args, pairwise_drop_na=True, alpha=.05, nboot=2000, seed=False) Compute a bootstrap confidence interval for a measure of location associated with the distribution of x-y. That is, compare x and y by looking at all possible difference scores in random samples of x and y . x and y are possibly dependent. Parameters: x: Pandas Series Data for group one y: Pandas Series Data for group two est: function Measure of location (currently only trim_mean is supported) *args: list/value Parameter(s) for measure of location (e.g., .2) pairwise_drop_na: bool If True, treat data as dependent and remove any row with missing data. If False, remove missing data for each group seperately (cannot deal with unequal sample sizes) alpha: float Alpha level. Default is .05. nboot: int Number of bootstrap samples. Default is 2000. seed: bool Random seed for reprodicible results. Default is False . Return: Dictonary of results Try this function right now in Colab!","title":"wincor"},{"location":"install_dep/","text":"Installation Hypothesize can be installed using pip : $ pip install hypothesize Dependencies Hypothesesize has the following dependencies, all of which are installed automatically with the above installation command: python 3.6 or newer NumPy Pandas SciPy more-itertools","title":"Installation"},{"location":"install_dep/#installation","text":"Hypothesize can be installed using pip : $ pip install hypothesize","title":"Installation"},{"location":"install_dep/#dependencies","text":"Hypothesesize has the following dependencies, all of which are installed automatically with the above installation command: python 3.6 or newer NumPy Pandas SciPy more-itertools","title":"Dependencies"},{"location":"junk/","text":"doc tools alerts A simple primary alert\u2014check it out! A simple info alert\u2014check it out! code def my_func(): i=1 print('hello_world') admonition optional explicit title within double quotes Any number of other indented markdown elements. def my_func(hello='world'): for item in my_list: print(item, 12) button this is a link-button this is a block link-button","title":"Junk"},{"location":"junk/#doc-tools","text":"alerts A simple primary alert\u2014check it out! A simple info alert\u2014check it out! code def my_func(): i=1 print('hello_world') admonition optional explicit title within double quotes Any number of other indented markdown elements. def my_func(hello='world'): for item in my_list: print(item, 12) button this is a link-button this is a block link-button","title":"doc tools"},{"location":"overview/","text":"Overview The benefits of using robust methods for hypothesis testing have been known for the last half century. They have been shown to subtantially increase power and accuracy when compared to traditional approaches. The issues of robustness and the functions in this library are described in detail in Rand R. Wilcox's book Introduction to Robust Estimation and Hypothesis Testing . The code and function names in Hypothesize are based on Wilcox's R functions in the WRS package. Hypothesize simply brings many of these helpful and well-studied robust methods to the Python ecosystem. In addition, Hypothesize provides a user-friendly API and package structure as well as one-click, ready-to-run examples for every top-level function. The Hypothesize API Hypothesize's API is friendly and consistent, making it easy for you to discover and use robust functions that are appropriate for your statistical design. Package Structure Hypothesize uses its package stucture to organize functions based on the statistical design. The following flow chart and GIF show how Hypothesize organizes its functions and how this is reflected in practice when importing from the library: graph TB linkStyle default interpolate basis A[Hypothesize] A --> B(compare groups with single factor) A --> C(compare groups with two factors) A --> D(measure associations) B --> F(f<sub>1</sub>) B --> G(f<sub>2</sub>) B --- H(f<sub>n</sub>) C --> F1(f<sub>1</sub>) C --> G2(f<sub>2</sub>) C --> H3(f<sub>n</sub>) D --> F5(f<sub>1</sub>) D --> G6(f<sub>2</sub>) D --> H7(f<sub>n</sub>) Input Parameters After importing the desired function, Hypothesize requires the necessary input arguments. For example, the following statistical test only requires the number of J and K levels, and the data to be specified (i.e., the parameter x ): from hypothesize.compare_groups_with_two_factors import bwmcp results=bwmcp(J=2, K=3, x=df) Depending on the statistical test, Hypothesize allows you to specify optional parameters to control the following (not an exhaustive list): The estimator. For example: trimmed mean winsorized correlation percentage bend correlation mean median For group comparisons, the trimmed mean may be the only supported robust estimator parameters specific to the chosen estimator (e.g., proportion to trim/winsorize, bending constant, etc) options for controlling FWE options for how to compute group differences (e.g., marginal, pairwise, all combinations of differences) number of bootstrap samples contrast matrix to specify linear contrasts alpha level random seed (for reprodicible results when using bootstrap-based tests) Visit the tutorial section and the function documentation for complete examples using Hypothesize.","title":"Overview"},{"location":"overview/#overview","text":"The benefits of using robust methods for hypothesis testing have been known for the last half century. They have been shown to subtantially increase power and accuracy when compared to traditional approaches. The issues of robustness and the functions in this library are described in detail in Rand R. Wilcox's book Introduction to Robust Estimation and Hypothesis Testing . The code and function names in Hypothesize are based on Wilcox's R functions in the WRS package. Hypothesize simply brings many of these helpful and well-studied robust methods to the Python ecosystem. In addition, Hypothesize provides a user-friendly API and package structure as well as one-click, ready-to-run examples for every top-level function.","title":"Overview"},{"location":"overview/#the-hypothesize-api","text":"Hypothesize's API is friendly and consistent, making it easy for you to discover and use robust functions that are appropriate for your statistical design.","title":"The Hypothesize API"},{"location":"overview/#package-structure","text":"Hypothesize uses its package stucture to organize functions based on the statistical design. The following flow chart and GIF show how Hypothesize organizes its functions and how this is reflected in practice when importing from the library: graph TB linkStyle default interpolate basis A[Hypothesize] A --> B(compare groups with single factor) A --> C(compare groups with two factors) A --> D(measure associations) B --> F(f<sub>1</sub>) B --> G(f<sub>2</sub>) B --- H(f<sub>n</sub>) C --> F1(f<sub>1</sub>) C --> G2(f<sub>2</sub>) C --> H3(f<sub>n</sub>) D --> F5(f<sub>1</sub>) D --> G6(f<sub>2</sub>) D --> H7(f<sub>n</sub>)","title":"Package Structure"},{"location":"overview/#input-parameters","text":"After importing the desired function, Hypothesize requires the necessary input arguments. For example, the following statistical test only requires the number of J and K levels, and the data to be specified (i.e., the parameter x ): from hypothesize.compare_groups_with_two_factors import bwmcp results=bwmcp(J=2, K=3, x=df) Depending on the statistical test, Hypothesize allows you to specify optional parameters to control the following (not an exhaustive list): The estimator. For example: trimmed mean winsorized correlation percentage bend correlation mean median For group comparisons, the trimmed mean may be the only supported robust estimator parameters specific to the chosen estimator (e.g., proportion to trim/winsorize, bending constant, etc) options for controlling FWE options for how to compute group differences (e.g., marginal, pairwise, all combinations of differences) number of bootstrap samples contrast matrix to specify linear contrasts alpha level random seed (for reprodicible results when using bootstrap-based tests) Visit the tutorial section and the function documentation for complete examples using Hypothesize.","title":"Input Parameters"}]}